<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firmador de Documentos APC - Lulo Panamá</title>
    <meta name="robots" content="nofollow">
    <style>
        :root {
            --lulo-panama-primary: #004951;
            --lulo-panama-secondary: #f3f3f3;
            --text-color: #333;
            --border-color: #ccc;
            --hover-bg-color: #e9f3f4;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px; /* Adjusted padding for smaller screens */
            background-color: var(--lulo-panama-secondary);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            background-color: white;
            padding: 15px; /* Adjusted padding */
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.1);
        }

        h1 {
            color: var(--lulo-panama-primary);
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.8em; /* Responsive font size */
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); /* Adjusted minmax */
            gap: 15px; /* Adjusted gap */
            margin-bottom: 20px;
        }

        .control-group {
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
        }

        .control-group h3 {
            margin-top: 0;
            color: var(--lulo-panama-primary);
            border-bottom: 1px solid var(--lulo-panama-primary);
            padding-bottom: 5px;
            font-size: 1.1em; /* Responsive font size */
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        input[type="text"],
        input[type="date"],
        input[type="number"],
        select {
            width: calc(100% - 22px);
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-sizing: border-box;
        }

        button {
            background-color: var(--lulo-panama-primary);
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin-right: 5px;
            margin-bottom: 5px;
        }

        button:hover {
            background-color: #003338;
        }

        .signature-pad-area {
            margin: 0 auto 10px auto; /* Center it */
            max-width: 380px; /* Max sensible size for the container */
        }
        
        #signatureCanvas {
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: crosshair;
            width: 100%; /* CSS display width fills container */
            height: auto; /* CSS display height maintains aspect ratio of attributes */
            display: block; /* Remove extra space */
        }

        .canvas-container {
            width: 100%;
            margin-bottom: 20px;
            position: relative; 
            max-height: 80vh; /* Limit height on large screens */
            overflow: auto; /* Allow scroll within this container if canvas is still too big */
            border: 1px solid var(--border-color); /* Optional: border for the scrollable area */
        }

        #mainDocumentCanvas {
            /* border: 1px solid var(--border-color); REMOVED: .canvas-container has border now */
            border-radius: 4px;
            display: block; 
            margin: 0 auto; 
            background-color: #f9f9f9; 
            max-width: 100%; /* Ensure canvas display isn't wider than its drawing surface if image is small */
            touch-action: none; /* Prevent default touch behaviors like scrolling/zooming on the canvas */
        }
        
        .selected-element-controls {
            padding: 10px;
            border: 1px dashed var(--lulo-panama-primary);
            margin-top: 10px;
            border-radius: 4px;
        }
        .selected-element-controls label {
             margin-top: 8px;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .container {
                padding: 10px;
            }
            h1 { font-size: 1.5em; }
            .control-group h3 { font-size: 1em; }
        }
         @media (max-width: 480px) {
            h1 { font-size: 1.3em; }
            button { padding: 8px 12px; font-size: 0.9em;}
            input[type="text"],
            input[type="date"],
            input[type="number"],
            select { padding: 8px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Firmador de Documentos APC</h1>

        <div class="controls-grid">
            <div class="control-group">
                <h3>1. Seleccione Documento y Complete sus Datos</h3>
                <label for="documentSelector">Plantilla APC:</label>
                <select id="documentSelector"></select>

                <label for="userName">Nombre Completo:</label>
                <input type="text" id="userName" placeholder="Escriba su nombre">

                <label for="userCedula">Cédula:</label>
                <input type="text" id="userCedula" placeholder="Escriba su cédula">

                <label for="userDate">Fecha:</label>
                <input type="text" id="userDate" placeholder="YYYY-MM-DD">
            </div>

            <div class="control-group">
                <h3>2. Firme Aquí</h3>
                <div class="signature-pad-area">
                    <canvas id="signatureCanvas" width="360" height="180"></canvas>
                </div>
                <button id="clearSignatureBtn">Limpiar Firma</button>
                <button id="confirmSignatureBtn">Confirmar Firma</button>
            </div>

            <div class="control-group" id="elementSizingControls" style="display:none;">
                <h3>3. Ajustar Elemento Seleccionado</h3>
                <p>Haga clic en un texto o firma sobre el documento para seleccionarlo y ajustar su tamaño aquí.</p>
                <div id="textElementControls" style="display:none;">
                    <label for="fontSize">Tamaño de Fuente (px):</label>
                    <input type="number" id="fontSize" min="8" max="72">
                </div>
                <div id="imageElementControls" style="display:none;">
                    <label for="imageWidth">Ancho de Firma (px):</label>
                    <input type="number" id="imageWidth" min="50" max="500">
                    <label for="imageHeight">Alto de Firma (px):</label>
                    <input type="number" id="imageHeight" min="25" max="250">
                </div>
            </div>
        </div>
        
        <div class="control-group">
            <h3>4. Visualice y Ajuste el Documento</h3>
            <p>Haga clic y arrastre los textos o la firma sobre el documento para cambiar su posición. Use los controles de la sección 3 para cambiar tamaños.</p>
        </div>

        <div class="canvas-container">
            <canvas id="mainDocumentCanvas"></canvas>
        </div>
        
        <div style="text-align: center; margin-top: 20px;">
            <button id="exportDocumentBtn">Exportar Documento Actual (JPG)</button>
        </div>

    </div>

    <script>
        const documentConfigurations = [
            { path: "apc/apc-multi-actual.jpg", shortName: "multi", displayName: "Multi" },
            { path: "apc/apc-bac-actual.jpg", shortName: "bac", displayName: "BAC" },
            { path: "apc/apc-global-actual.jpg", shortName: "global", displayName: "Global" }
        ];

        const appState = {
            currentDocumentUrl: null,
            sharedInputs: {
                name: '',
                cedula: '',
                date: new Date().toISOString().slice(0,10),
            },
            signatureImageCache: null, 
            documentSettings: {}, 
            activeElementId: null, 
            dragState: {
                isDragging: false,
                elementId: null,
                offsetX: 0,
                offsetY: 0
            },
            backgroundImage: null, 
            canvasScaleFactor: 1, 
        };

        const documentSelector = document.getElementById('documentSelector');
        const userNameInput = document.getElementById('userName');
        const userCedulaInput = document.getElementById('userCedula');
        const userDateInput = document.getElementById('userDate');
        
        const signaturePad = document.getElementById('signatureCanvas');
        const sigCtx = signaturePad.getContext('2d');
        const clearSignatureBtn = document.getElementById('clearSignatureBtn');
        const confirmSignatureBtn = document.getElementById('confirmSignatureBtn');

        const mainCanvas = document.getElementById('mainDocumentCanvas');
        const mainCtx = mainCanvas.getContext('2d');

        const exportDocumentBtn = document.getElementById('exportDocumentBtn');

        const elementSizingControls = document.getElementById('elementSizingControls');
        const textElementControls = document.getElementById('textElementControls');
        const fontSizeInput = document.getElementById('fontSize');
        const imageElementControls = document.getElementById('imageElementControls');
        const imageWidthInput = document.getElementById('imageWidth');
        const imageHeightInput = document.getElementById('imageHeight');

        let isDrawingSig = false;
        let lastSigX = 0;
        let lastSigY = 0;

        function setupSignaturePadContext() {
            sigCtx.strokeStyle = '#000000';
            sigCtx.lineWidth = 2; // Adjust thickness as needed
            sigCtx.lineCap = 'round';
            sigCtx.lineJoin = 'round';
        }

        function initializeDefaultDocumentSettings() {
            const defaultFontSize = 20; 
            const defaultSigWidth = 150;
            const defaultSigHeight = 75;
            
            documentConfigurations.forEach(docConfig => {
                const docPath = docConfig.path;
                if (!appState.documentSettings[docPath]) {
                    appState.documentSettings[docPath] = {
                        elements: [
                            { id: 'name', type: 'text', x: 50, y: 50, fontSize: defaultFontSize, color: '#000000' },
                            { id: 'cedula', type: 'text', x: 50, y: 90, fontSize: defaultFontSize, color: '#000000' },
                            { id: 'date', type: 'text', x: 50, y: 130, fontSize: defaultFontSize, color: '#000000' },
                            { id: 'signature', type: 'image', x: 50, y: 170, width: defaultSigWidth, height: defaultSigHeight }
                        ]
                    };
                }
            });
        }
        
        function populateDocumentSelector() {
            documentConfigurations.forEach(docConfig => {
                const option = document.createElement('option');
                option.value = docConfig.path;
                option.textContent = docConfig.displayName; 
                documentSelector.appendChild(option);
            });
        }

        function handleUrlParameters() {
            const params = new URLSearchParams(window.location.search);
            let selectedDocPath = null;

            const eParamValue = params.get('e');
            if (eParamValue) {
                const foundDoc = documentConfigurations.find(doc => doc.shortName.toLowerCase() === eParamValue.toLowerCase());
                if (foundDoc) {
                    selectedDocPath = foundDoc.path;
                }
            }

            if (!selectedDocPath) {
                for (const docConfig of documentConfigurations) {
                    if (params.has(docConfig.shortName.toLowerCase())) {
                        selectedDocPath = docConfig.path;
                        break; 
                    }
                }
            }

            if (selectedDocPath) {
                documentSelector.value = selectedDocPath;
            }
        }

        function loadDocument(docUrl) {
            appState.currentDocumentUrl = docUrl;
            appState.backgroundImage = new Image();
            appState.backgroundImage.onload = () => {
                const canvasContainer = mainCanvas.parentElement;
                const canvasContainerWidth = canvasContainer.clientWidth;
                
                // Respect max-height of container by calculating max allowed width based on aspect ratio
                const imageAspectRatio = appState.backgroundImage.naturalWidth / appState.backgroundImage.naturalHeight;
                let canvasWidth = Math.min(appState.backgroundImage.naturalWidth, canvasContainerWidth);
                let canvasHeight = canvasWidth / imageAspectRatio;

                const containerStyle = getComputedStyle(canvasContainer);
                const containerMaxHeight = parseFloat(containerStyle.maxHeight);

                if (canvasHeight > containerMaxHeight) {
                    canvasHeight = containerMaxHeight;
                    canvasWidth = canvasHeight * imageAspectRatio;
                }
                // Ensure canvas width does not exceed container width if height constraint made it wider
                canvasWidth = Math.min(canvasWidth, canvasContainerWidth);


                mainCanvas.width = canvasWidth;
                mainCanvas.height = canvasHeight; 
                                
                appState.canvasScaleFactor = mainCanvas.width / appState.backgroundImage.naturalWidth;

                redrawMainCanvas();
                updateSelectedElementControls(); 
            };
            appState.backgroundImage.onerror = () => {
                console.error("Error cargando imagen del documento:", docUrl);
                mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
                mainCtx.fillStyle = "red";
                mainCtx.font = "16px Arial";
                mainCtx.textAlign = "center";
                const currentDocConfig = documentConfigurations.find(dc => dc.path === docUrl);
                const docName = currentDocConfig ? currentDocConfig.displayName : docUrl.split('/').pop();
                mainCtx.fillText("Error al cargar: " + docName, mainCanvas.width / 2, mainCanvas.height / 2);
            }
            appState.backgroundImage.src = docUrl;
        }
        
        function getElementById(docUrl, elementId) {
            if (appState.documentSettings[docUrl]) {
                return appState.documentSettings[docUrl].elements.find(el => el.id === elementId);
            }
            return null;
        }

        function redrawMainCanvas(isExporting = false) {
            if (!appState.currentDocumentUrl || !appState.backgroundImage || !appState.backgroundImage.complete) {
                 mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
                 mainCtx.fillStyle = "gray";
                 mainCtx.font = "16px Arial";
                 mainCtx.textAlign = "center";
                 mainCtx.fillText("Cargando documento...", mainCanvas.width / 2, mainCanvas.height / 2);
                return;
            }
            
            mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
            mainCtx.drawImage(appState.backgroundImage, 0, 0, mainCanvas.width, mainCanvas.height);

            const currentDocSettings = appState.documentSettings[appState.currentDocumentUrl];
            if (!currentDocSettings) return;

            currentDocSettings.elements.forEach(element => {
                mainCtx.fillStyle = element.color || '#000000';
                mainCtx.strokeStyle = 'var(--lulo-panama-primary)'; 
                mainCtx.lineWidth = 1.5; // Slightly thicker selection box

                if (element.type === 'text') {
                    const textContent = appState.sharedInputs[element.id] || '';
                    mainCtx.font = `${element.fontSize}px Arial`;
                    mainCtx.fillText(textContent, element.x, element.y);
                    if (appState.activeElementId === element.id && !isExporting) {
                        const textMetrics = mainCtx.measureText(textContent);
                        const actualHeight = element.fontSize * 1.2; 
                        mainCtx.strokeRect(element.x - 3, element.y - actualHeight + (element.fontSize*0.2) - 1 , textMetrics.width + 6, actualHeight + 2); // slightly larger selection
                    }
                } else if (element.type === 'image' && element.id === 'signature') {
                    if (appState.signatureImageCache) {
                        mainCtx.drawImage(appState.signatureImageCache, element.x, element.y, element.width, element.height);
                        if (appState.activeElementId === element.id && !isExporting) {
                             mainCtx.strokeRect(element.x - 1, element.y - 1, element.width + 2, element.height + 2); // slightly larger selection
                        }
                    }
                }
            });
        }

        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
        }
        function getTouchPos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            // Ensure touches exists and has at least one touch point
            if (evt.touches && evt.touches.length > 0) {
                return { x: evt.touches[0].clientX - rect.left, y: evt.touches[0].clientY - rect.top };
            }
            // Fallback or error if no touch point (should not happen in touchstart/move)
            return { x: 0, y: 0}; 
        }


        function startDrawingSig(e) {
            isDrawingSig = true;
            const pos = e.touches ? getTouchPos(signaturePad, e) : getMousePos(signaturePad, e);
            if (pos.x === 0 && pos.y === 0 && e.touches && e.touches.length === 0) return; // Avoid error if getTouchPos fails
            
            sigCtx.beginPath(); // Start a new path
            sigCtx.moveTo(pos.x, pos.y);
            lastSigX = pos.x; // Store last point for moveTo in subsequent drawSig calls if it was just a tap
            lastSigY = pos.y;
            e.preventDefault();
        }

        function drawSig(e) {
            if (!isDrawingSig) return;
            const pos = e.touches ? getTouchPos(signaturePad, e) : getMousePos(signaturePad, e);
            if (pos.x === 0 && pos.y === 0 && e.touches && e.touches.length === 0) return;

            // sigCtx.beginPath(); // Not here, continuous line
            // sigCtx.moveTo(lastSigX, lastSigY); // Not needed if path is continuous
            sigCtx.lineTo(pos.x, pos.y);
            sigCtx.stroke(); // Render the line segment
            
            // Update last position for next segment
            lastSigX = pos.x;
            lastSigY = pos.y;
            e.preventDefault();
        }
        
        function stopDrawingSig(e) {
            if (isDrawingSig) {
                // If it was a very short interaction (tap), draw a small dot.
                // Check if lineTo was ever called effectively. If lastX,Y is still start point, draw dot.
                // This is tricky; for now, simple stop.
                isDrawingSig = false;
                // sigCtx.closePath(); // Not strictly necessary for stroke only
            }
            e.preventDefault(); // Prevent any further default action on touchend/mouseup
        }
        
        function clearSignature() {
            sigCtx.clearRect(0, 0, signaturePad.width, signaturePad.height);
            appState.signatureImageCache = null; 
            redrawMainCanvas();
        }

        function confirmSignature() {
            const tempImage = new Image();
            tempImage.onload = () => {
                appState.signatureImageCache = tempImage;
                redrawMainCanvas();
            }
            // Trim whitespace from signature before saving (basic version)
            // More advanced trimming would analyze pixels.
            // For now, just use toDataURL directly.
            tempImage.src = signaturePad.toDataURL('image/png');
        }

        function getCanvasCoordinates(event) {
            const rect = mainCanvas.getBoundingClientRect();
            let x, y;
            if (event.touches && event.touches.length > 0) {
                x = event.touches[0].clientX - rect.left;
                y = event.touches[0].clientY - rect.top;
            } else if (event.clientX !== undefined) { // Mouse event
                x = event.clientX - rect.left;
                y = event.clientY - rect.top;
            } else {
                 return null; // Should not happen
            }
            return { x, y };
        }
        
        function isPointInElement(pointX, pointY, element) {
            let x, y, width, height;
            if (element.type === 'text') {
                mainCtx.font = `${element.fontSize}px Arial`; 
                const textContent = appState.sharedInputs[element.id] || '';
                const textMetrics = mainCtx.measureText(textContent);
                x = element.x;
                y = element.y - element.fontSize; 
                width = textMetrics.width || element.fontSize; // Min width for empty string
                height = element.fontSize * 1.2; 
            } else if (element.type === 'image') {
                x = element.x;
                y = element.y;
                width = element.width;
                height = element.height;
            } else {
                return false;
            }
            return pointX >= x && pointX <= x + width && pointY >= y && pointY <= y + height;
        }

        function handleCanvasMouseDown(event) {
            const coords = getCanvasCoordinates(event);
            if (!coords) return;
            const { x, y } = coords;

            const currentDocSettings = appState.documentSettings[appState.currentDocumentUrl];
            if (!currentDocSettings) return;

            let selected = null;
            // Iterate in reverse to select top-most element if overlapping
            for (let i = currentDocSettings.elements.length - 1; i >= 0; i--) {
                const element = currentDocSettings.elements[i];
                if (isPointInElement(x, y, element)) {
                    selected = element;
                    break;
                }
            }
            
            if (selected) {
                appState.activeElementId = selected.id;
                appState.dragState = {
                    isDragging: true,
                    elementId: selected.id,
                    offsetX: x - selected.x,
                    offsetY: y - selected.y
                };
            } else {
                appState.activeElementId = null;
                appState.dragState.isDragging = false;
            }
            updateSelectedElementControls();
            redrawMainCanvas();
            event.preventDefault(); // Crucial for preventing page scroll/etc.
        }

        function handleCanvasMouseMove(event) {
            if (!appState.dragState.isDragging || !appState.dragState.elementId) return;
            
            const coords = getCanvasCoordinates(event);
            if (!coords) return;
            const { x, y } = coords;
            
            const element = getElementById(appState.currentDocumentUrl, appState.dragState.elementId);
            
            if (element) {
                element.x = x - appState.dragState.offsetX;
                element.y = y - appState.dragState.offsetY;
                redrawMainCanvas();
            }
            event.preventDefault(); // Crucial
        }

        function handleCanvasMouseUp(event) { // event might be needed if we want to check something on up
            if (appState.dragState.isDragging) { // Only change state if actively dragging
                appState.dragState.isDragging = false;
            }
            // Do not preventDefault here unconditionally, as it might block legitimate "click" events
            // if the mouseup is part of a click that wasn't a drag.
            // However, if a drag occurred, the default (like text selection) should already be prevented by move/start.
        }
         function handleCanvasMouseLeave(event) { // If mouse leaves canvas while dragging
            if (appState.dragState.isDragging) {
                appState.dragState.isDragging = false;
                // Optionally, you could also redraw here if dragging state influenced appearance beyond selection box
            }
        }
        
        function updateSelectedElementControls() {
            const activeElement = appState.activeElementId ? getElementById(appState.currentDocumentUrl, appState.activeElementId) : null;

            if (activeElement) {
                elementSizingControls.style.display = 'block';
                if (activeElement.type === 'text') {
                    textElementControls.style.display = 'block';
                    imageElementControls.style.display = 'none';
                    fontSizeInput.value = activeElement.fontSize;
                } else if (activeElement.type === 'image') {
                    textElementControls.style.display = 'none';
                    imageElementControls.style.display = 'block';
                    imageWidthInput.value = activeElement.width;
                    imageHeightInput.value = activeElement.height;
                }
            } else {
                elementSizingControls.style.display = 'none';
                textElementControls.style.display = 'none';
                imageElementControls.style.display = 'none';
            }
        }

        function handleSizeInputChange() {
            const activeElement = appState.activeElementId ? getElementById(appState.currentDocumentUrl, appState.activeElementId) : null;
            if (!activeElement) return;

            if (activeElement.type === 'text') {
                activeElement.fontSize = parseInt(fontSizeInput.value, 10) || 20;
            } else if (activeElement.type === 'image') {
                activeElement.width = parseInt(imageWidthInput.value, 10) || 150;
                activeElement.height = parseInt(imageHeightInput.value, 10) || 75;
            }
            redrawMainCanvas();
        }

        documentSelector.addEventListener('change', (e) => {
            appState.activeElementId = null; 
            updateSelectedElementControls();
            loadDocument(e.target.value);
        });

        userNameInput.addEventListener('input', (e) => { appState.sharedInputs.name = e.target.value; redrawMainCanvas(); });
        userCedulaInput.addEventListener('input', (e) => { appState.sharedInputs.cedula = e.target.value; redrawMainCanvas(); });
        userDateInput.addEventListener('input', (e) => { appState.sharedInputs.date = e.target.value; redrawMainCanvas(); });

        signaturePad.addEventListener('mousedown', startDrawingSig);
        signaturePad.addEventListener('mousemove', drawSig);
        signaturePad.addEventListener('mouseup', stopDrawingSig);
        signaturePad.addEventListener('mouseleave', stopDrawingSig); // Stop if mouse leaves canvas
        signaturePad.addEventListener('touchstart', startDrawingSig, { passive: false });
        signaturePad.addEventListener('touchmove', drawSig, { passive: false });
        signaturePad.addEventListener('touchend', stopDrawingSig);
        
        clearSignatureBtn.addEventListener('click', clearSignature);
        confirmSignatureBtn.addEventListener('click', confirmSignature);

        mainCanvas.addEventListener('mousedown', handleCanvasMouseDown);
        mainCanvas.addEventListener('mousemove', handleCanvasMouseMove);
        mainCanvas.addEventListener('mouseup', handleCanvasMouseUp);
        mainCanvas.addEventListener('mouseleave', handleCanvasMouseLeave); 
        mainCanvas.addEventListener('touchstart', handleCanvasMouseDown, { passive: false });
        mainCanvas.addEventListener('touchmove', handleCanvasMouseMove, { passive: false });
        mainCanvas.addEventListener('touchend', handleCanvasMouseUp);

        fontSizeInput.addEventListener('change', handleSizeInputChange);
        imageWidthInput.addEventListener('change', handleSizeInputChange);
        imageHeightInput.addEventListener('change', handleSizeInputChange);

        exportDocumentBtn.addEventListener('click', () => {
            if (!appState.currentDocumentUrl || !appState.backgroundImage || !appState.backgroundImage.complete) {
                alert("Por favor, seleccione y cargue un documento primero.");
                return;
            }
            const lastActiveElement = appState.activeElementId;
            appState.activeElementId = null;
            redrawMainCanvas(true); 

            const dataUrl = mainCanvas.toDataURL('image/jpeg', 0.9); 
            const link = document.createElement('a');
            link.href = dataUrl;
            
            const currentDocConfig = documentConfigurations.find(dc => dc.path === appState.currentDocumentUrl);
            const shortNameForFile = currentDocConfig ? currentDocConfig.shortName : 'documento';
            const dateForFile = appState.sharedInputs.date.replace(/-/g,'') || new Date().toISOString().slice(0,10).replace(/-/g,'');
            link.download = `APC_Firmado_${shortNameForFile}_${dateForFile}.jpg`;
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            appState.activeElementId = lastActiveElement;
            if(lastActiveElement) redrawMainCanvas(); // Redraw with selection only if something was active
        });

        function handleAppResize() {
             if (appState.currentDocumentUrl && appState.backgroundImage && appState.backgroundImage.complete) {
                // Recalculate main document canvas size
                loadDocument(appState.currentDocumentUrl); // This will re-calculate sizes and redraw
            }
            // Signature pad does not need JS resize if its width/height attributes are fixed
            // and CSS handles its display scaling (width:100%, height:auto).
            // If signature pad canvas attributes were changed dynamically, you'd call its resize here.
            setupSignaturePadContext(); // Ensure context settings are reapplied if needed (e.g. if canvas was cleared or recreated)

        }
        window.addEventListener('resize', handleAppResize);

        // Initialization
        initializeDefaultDocumentSettings();
        populateDocumentSelector();
        handleUrlParameters(); 
        setupSignaturePadContext(); // Initial setup for signature context

        userNameInput.value = appState.sharedInputs.name;
        userCedulaInput.value = appState.sharedInputs.cedula;
        userDateInput.value = appState.sharedInputs.date;
        
        if (documentSelector.value) { 
            loadDocument(documentSelector.value);
        } else if (documentConfigurations.length > 0) { 
            documentSelector.value = documentConfigurations[0].path;
            loadDocument(documentConfigurations[0].path);
        } else {
            console.error("No hay documentos APC configurados.");
            mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
            mainCtx.fillStyle = "red";
            mainCtx.font = "16px Arial";
            mainCtx.textAlign = "center";
            mainCtx.fillText("No hay documentos APC configurados.", mainCanvas.width / 2, mainCanvas.height / 2);
        }
    </script>
</body>
</html>
