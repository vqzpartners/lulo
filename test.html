<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Firmador de Documentos APC - Lulo Panamá</title>
    <meta name="robots" content="nofollow">
    <style>
        :root {
            --lulo-panama-primary: #004951;
            --lulo-panama-secondary: #f3f3f3;
            --text-color: #333;
            --border-color: #ccc;
            --selection-border-color: #007bff; 
        }
        html, body { overscroll-behavior-y: contain; }
        body {
            font-family: Arial, sans-serif; margin: 0; padding: 10px; 
            background-color: var(--lulo-panama-secondary); color: var(--text-color);
            display: flex; flex-direction: column; align-items: center;
        }
        .container {
            width: 100%; max-width: 1200px; background-color: white;
            padding: 15px; border-radius: 8px; box-shadow: 0 0 15px rgba(0,0,0,0.1);
        }
        h1 {
            color: var(--lulo-panama-primary); text-align: center;
            margin-bottom: 20px; font-size: 1.8em; 
        }
        .main-layout-grid { display: grid; grid-template-columns: 1fr; gap: 20px; }
        .document-display-area { grid-column: 1 / -1; }
        .input-areas-grid { 
            display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); 
            gap: 15px; margin-bottom: 20px;
        }
        .control-group {
            padding: 15px; border: 1px solid var(--border-color);
            border-radius: 5px; background-color: #fdfdfd;
        }
        .control-group h3 {
            margin-top: 0; color: var(--lulo-panama-primary);
            border-bottom: 1px solid var(--lulo-panama-primary);
            padding-bottom: 5px; font-size: 1.1em; 
        }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input[type="number"] { /* Removed select styling as it's replaced */
            width: calc(100% - 22px); padding: 10px; margin-bottom: 10px;
            border: 1px solid var(--border-color); border-radius: 4px; box-sizing: border-box;
        }
        button {
            background-color: var(--lulo-panama-primary); color: white; padding: 10px 15px;
            border: none; border-radius: 4px; cursor: pointer;
            transition: background-color 0.3s ease; margin-right: 5px; margin-bottom: 5px;
        }
        button:hover { background-color: #003338; }
        
        .document-buttons button { /* Styling for document selector buttons */
            width: calc(33.33% - 10px); /* Adjust for 3 buttons per row, with gap */
            margin: 5px;
            box-sizing: border-box;
        }
        .document-buttons button.active {
            background-color: #003338;
            border: 2px solid var(--selection-border-color);
        }


        .handwriting-pad-area, .signature-pad-area {
            margin: 0 auto 10px auto; max-width: 380px; 
        }
        .handwriting-canvas, #signatureCanvas, #dateCanvas { 
            border: 1px dashed var(--border-color); border-radius: 4px; cursor: crosshair;
            width: 100%; height: auto; display: block; 
        }
        .canvas-container {
            width: 100%; margin-bottom: 20px; position: relative; 
            max-height: 75vh; 
            overflow: auto; border: 1px solid var(--border-color); 
            background-color: #e0e0e0; /* Background for the scrollable container itself */
        }
        #mainDocumentCanvas {
            border-radius: 4px; display: block; margin: 0 auto; 
            /* background-color: #e8e8e8; Removed, container has bg now */
            touch-action: none; 
        }
        .selected-element-controls {
            padding: 10px; border: 1px dashed var(--lulo-panama-primary);
            margin-top: 10px; border-radius: 4px;
        }
        .selected-element-controls label { margin-top: 8px; }

        @media (min-width: 992px) { 
            .main-layout-grid { grid-template-columns: 400px 1fr; }
            .input-areas-grid { grid-template-columns: 1fr; }
            .document-display-area { grid-column: 2 / 3; }
            .document-buttons button { width: calc(100% - 10px); } /* Full width in sidebar */
        }
        @media (max-width: 768px) {
            body { padding: 10px; } .container { padding: 10px;}
            h1 { font-size: 1.5em; } .control-group h3 { font-size: 1em; }
        }
         @media (max-width: 480px) {
            h1 { font-size: 1.3em; }
            button { padding: 8px 12px; font-size: 0.9em;}
            input[type="number"] { padding: 8px; }
            .document-buttons button { width: calc(50% - 10px); } /* Two buttons per row on small mobile */
        }
        @media (max-width: 380px) {
            .document-buttons button { width: calc(100% - 10px); } /* One button per row on very small mobile */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Firmador de Documentos APC</h1>
        <div class="main-layout-grid">
            <div class="input-areas-container">
                <div class="input-areas-grid">
                    <div class="control-group">
                        <h3>1. Seleccione Documento</h3>
                        <div id="documentButtonContainer" class="document-buttons"></div>
                    </div>
                    <div class="control-group">
                        <h3>2. Nombre (Manuscrito)</h3>
                        <div class="handwriting-pad-area">
                            <canvas class="handwriting-canvas" id="nameCanvas" data-logical-width="360" data-logical-height="100"></canvas>
                        </div>
                        <button id="clearNameBtn">Limpiar Nombre</button>
                        <button id="confirmNameBtn">Confirmar Nombre</button>
                    </div>
                    <div class="control-group">
                        <h3>3. Cédula (Manuscrita)</h3>
                        <div class="handwriting-pad-area">
                            <canvas class="handwriting-canvas" id="cedulaCanvas" data-logical-width="360" data-logical-height="100"></canvas>
                        </div>
                        <button id="clearCedulaBtn">Limpiar Cédula</button>
                        <button id="confirmCedulaBtn">Confirmar Cédula</button>
                    </div>
                     <div class="control-group"> 
                        <h3>4. Fecha (Manuscrita)</h3>
                        <div class="handwriting-pad-area">
                            <canvas class="handwriting-canvas" id="dateCanvas" data-logical-width="360" data-logical-height="80"></canvas>
                        </div>
                        <button id="clearDateBtn">Limpiar Fecha</button>
                        <button id="confirmDateBtn">Confirmar Fecha</button>
                    </div>
                    <div class="control-group">
                        <h3>5. Firma</h3> 
                        <div class="signature-pad-area">
                            <canvas id="signatureCanvas" data-logical-width="360" data-logical-height="120"></canvas>
                        </div>
                        <button id="clearSignatureBtn">Limpiar Firma</button>
                        <button id="confirmSignatureBtn">Confirmar Firma</button>
                    </div>
                     <div class="control-group" id="elementSizingControls" style="display:none;">
                        <h3>6. Ajustar Elemento</h3>
                        <p>Haga clic en un elemento sobre el documento para seleccionarlo y ajustar su tamaño aquí. En móvil, puede pellizcar para escalar.</p>
                        <div id="imageElementControls"> 
                            <label for="elementWidth">Ancho del Elemento (px):</label>
                            <input type="number" id="elementWidth" min="20" max="800">
                            <label for="elementHeight">Alto del Elemento (px):</label>
                            <input type="number" id="elementHeight" min="20" max="800">
                        </div>
                    </div>
                </div>
            </div>
            <div class="document-display-area">
                 <div class="control-group">
                    <h3>Visualice y Ajuste el Documento</h3>
                    <p>Haga clic y arrastre los elementos. Use los controles (Sección 6) o pellizque en móvil para cambiar tamaños.</p>
                </div>
                <div class="canvas-container">
                    <canvas id="mainDocumentCanvas"></canvas>
                </div>
                <div style="text-align: center; margin-top: 20px;">
                    <button id="exportDocumentBtn">Exportar Documento Actual (JPG)</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const dpr = window.devicePixelRatio || 1;
        const documentConfigurations = [
            { path: "apc/apc-multi-actual.jpg", shortName: "multi", displayName: "Multi" },
            { path: "apc/apc-bac-actual.jpg", shortName: "bac", displayName: "BAC" },
            { path: "apc/apc-global-actual.jpg", shortName: "global", displayName: "Global" }
        ];

        const appState = {
            currentDocumentUrl: null,
            nameImageCache: null, cedulaImageCache: null, dateImageCache: null, signatureImageCache: null, 
            documentSettings: {}, activeElementId: null, 
            dragState: { isDragging: false, elementId: null, offsetX: 0, offsetY: 0 },
            pinchState: { isPinching: false, initialPinchDistance: 0, initialElement: {}, elementId: null },
            backgroundImage: null, 
            lastPadResizeDimensions: {} // To track pad sizes and avoid unnecessary re-init
        };

        const documentButtonContainer = document.getElementById('documentButtonContainer'); // New container for buttons
        const nameCanvasEl = document.getElementById('nameCanvas'); // Changed to El suffix for clarity
        const clearNameBtn = document.getElementById('clearNameBtn');
        const confirmNameBtn = document.getElementById('confirmNameBtn');
        let nameCtx; 
        const cedulaCanvasEl = document.getElementById('cedulaCanvas'); // Changed to El suffix
        const clearCedulaBtn = document.getElementById('clearCedulaBtn');
        const confirmCedulaBtn = document.getElementById('confirmCedulaBtn');
        let cedulaCtx; 
        const dateCanvasEl = document.getElementById('dateCanvas'); 
        const clearDateBtn = document.getElementById('clearDateBtn');
        const confirmDateBtn = document.getElementById('confirmDateBtn');
        let dateCtx;
        const signaturePadEl = document.getElementById('signatureCanvas'); // Changed to El suffix
        const clearSignatureBtn = document.getElementById('clearSignatureBtn');
        const confirmSignatureBtn = document.getElementById('confirmSignatureBtn');
        let sigCtx; 
        const mainCanvas = document.getElementById('mainDocumentCanvas');
        let mainCtx = mainCanvas.getContext('2d'); // Initialize, will be reconfigured
        const exportDocumentBtn = document.getElementById('exportDocumentBtn');
        const elementSizingControls = document.getElementById('elementSizingControls');
        const imageElementControls = document.getElementById('imageElementControls');
        const elementWidthInput = document.getElementById('elementWidth');
        const elementHeightInput = document.getElementById('elementHeight');

        let drawingStates = {
            name: {isDrawing: false, lastX:0, lastY:0},
            cedula: {isDrawing: false, lastX:0, lastY:0},
            date: {isDrawing: false, lastX:0, lastY:0}, 
            signature: {isDrawing: false, lastX:0, lastY:0}
        };
        
        // --- Canvas Setup and DPR Scaling ---
        // Configure context (call after dimensions are set/reset)
        function configureDrawingContext(ctx, logicalWidth, logicalHeight) {
            ctx.resetTransform(); 
            ctx.scale(dpr, dpr);
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2; // Logical line width
            ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            ctx.clearRect(0, 0, logicalWidth, logicalHeight); // Clear to transparent
        }

        // Setup canvas dimensions and initial context configuration
        function setupDrawingCanvas(canvasEl, stateKey) {
            const logicalWidth = parseInt(canvasEl.dataset.logicalWidth);
            const logicalHeight = parseInt(canvasEl.dataset.logicalHeight);
            
            canvasEl.style.width = logicalWidth + 'px';
            canvasEl.style.height = logicalHeight + 'px';
            canvasEl.width = logicalWidth * dpr;
            canvasEl.height = logicalHeight * dpr;
            
            const ctx = canvasEl.getContext('2d');
            configureDrawingContext(ctx, logicalWidth, logicalHeight);

            // Event listeners attached ONCE per element
            if (!canvasEl.dataset.listenersAttached) {
                canvasEl.addEventListener('mousedown', (e) => startDrawing(e, ctx, stateKey, canvasEl));
                canvasEl.addEventListener('mousemove', (e) => draw(e, ctx, stateKey, canvasEl));
                canvasEl.addEventListener('mouseup', () => stopDrawing(stateKey));
                canvasEl.addEventListener('mouseleave', () => stopDrawing(stateKey));
                canvasEl.addEventListener('touchstart', (e) => startDrawing(e, ctx, stateKey, canvasEl), { passive: false });
                canvasEl.addEventListener('touchmove', (e) => draw(e, ctx, stateKey, canvasEl), { passive: false });
                canvasEl.addEventListener('touchend', () => stopDrawing(stateKey));
                canvasEl.dataset.listenersAttached = 'true';
            }
            return ctx;
        }
        
        function initializeDrawingPads() {
            nameCtx = setupDrawingCanvas(nameCanvasEl, 'name');
            cedulaCtx = setupDrawingCanvas(cedulaCanvasEl, 'cedula');
            dateCtx = setupDrawingCanvas(dateCanvasEl, 'date');
            sigCtx = setupDrawingCanvas(signaturePadEl, 'signature');
            
            // Store initial dimensions to compare on resize
            [nameCanvasEl, cedulaCanvasEl, dateCanvasEl, signaturePadEl].forEach(el => {
                appState.lastPadResizeDimensions[el.id] = { 
                    width: el.clientWidth, 
                    height: el.clientHeight 
                };
            });
        }

        function getPadCoordinates(canvasEl, event) {
            const rect = canvasEl.getBoundingClientRect();
            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX; clientY = event.touches[0].clientY;
            } else if (event.clientX !== undefined) {
                clientX = event.clientX; clientY = event.clientY;
            } else { return null; }
            const logicalWidth = parseInt(canvasEl.dataset.logicalWidth);
            const logicalHeight = parseInt(canvasEl.dataset.logicalHeight);
            if (rect.width === 0 || rect.height === 0) return {x:0, y:0};
            return { 
                x: (clientX - rect.left) * (logicalWidth / rect.width),
                y: (clientY - rect.top) * (logicalHeight / rect.height)
            };
        }

        function startDrawing(e, ctx, stateKey, canvasReference) { 
            const padState = drawingStates[stateKey];
            padState.isDrawing = true;
            const coords = getPadCoordinates(canvasReference, e); 
            if (!coords) return;
            ctx.beginPath(); ctx.moveTo(coords.x, coords.y);
            padState.lastX = coords.x; padState.lastY = coords.y;
            if(e.cancelable) e.preventDefault();
        }

        function draw(e, ctx, stateKey, canvasReference) { 
            const padState = drawingStates[stateKey];
            if (!padState.isDrawing) return;
            const coords = getPadCoordinates(canvasReference, e); 
            if (!coords) return;
            ctx.lineTo(coords.x, coords.y); ctx.stroke(); 
            padState.lastX = coords.x; padState.lastY = coords.y;
            if(e.cancelable) e.preventDefault();
        }
        
        function stopDrawing(stateKey) {
            if (drawingStates[stateKey].isDrawing) drawingStates[stateKey].isDrawing = false;
        }

        function clearDrawingPad(ctx, imageCacheKey) { 
            const logicalWidth = parseInt(ctx.canvas.dataset.logicalWidth);
            const logicalHeight = parseInt(ctx.canvas.dataset.logicalHeight);
            ctx.clearRect(0, 0, logicalWidth, logicalHeight); 
            appState[imageCacheKey] = null; redrawMainCanvas();
        }

        function confirmDrawingPad(ctx, imageCacheKey) {
            const tempImage = new Image();
            tempImage.onload = () => { appState[imageCacheKey] = tempImage; redrawMainCanvas(); }
            tempImage.src = ctx.canvas.toDataURL('image/png'); 
        }

        function initializeDefaultDocumentSettings() {
            const defaultElementWidth = 180; const defaultElementHeight = 50; 
            const defaultDateHeight = 40; const defaultSigWidth = 200; const defaultSigHeight = 80;
            documentConfigurations.forEach(docConfig => {
                const docPath = docConfig.path;
                if (!appState.documentSettings[docPath]) {
                    appState.documentSettings[docPath] = {
                        elements: [ 
                            { id: 'name', type: 'image', x: 50, y: 50, width: defaultElementWidth, height: defaultElementHeight },
                            { id: 'cedula', type: 'image', x: 50, y: 110, width: defaultElementWidth, height: defaultElementHeight },
                            { id: 'date', type: 'image', x: 50, y: 170, width: defaultElementWidth, height: defaultDateHeight },
                            { id: 'signature', type: 'image', x: 50, y: 220, width: defaultSigWidth, height: defaultSigHeight }
                        ]};
                }});
        }
        
        function populateDocumentButtons() { // Changed from populateDocumentSelector
            documentButtonContainer.innerHTML = ''; // Clear existing buttons
            documentConfigurations.forEach(docConfig => {
                const button = document.createElement('button');
                button.textContent = docConfig.displayName;
                button.dataset.docPath = docConfig.path;
                button.addEventListener('click', () => {
                    loadDocument(docConfig.path);
                    setActiveDocumentButton(docConfig.path);
                });
                documentButtonContainer.appendChild(button);
            });
        }

        function setActiveDocumentButton(docPath) {
            const buttons = documentButtonContainer.querySelectorAll('button');
            buttons.forEach(btn => {
                if (btn.dataset.docPath === docPath) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }
        
        function handleUrlParameters() {
            const params = new URLSearchParams(window.location.search);
            let selectedDocPath = null;
            const eParamValue = params.get('e');
            if (eParamValue) {
                const foundDoc = documentConfigurations.find(doc => doc.shortName.toLowerCase() === eParamValue.toLowerCase());
                if (foundDoc) selectedDocPath = foundDoc.path;
            }
            if (!selectedDocPath) {
                for (const docConfig of documentConfigurations) {
                    if (params.has(docConfig.shortName.toLowerCase())) {
                        selectedDocPath = docConfig.path; break; 
                    }}}
            if (selectedDocPath) { // Don't set .value on a div, handle button state
                return selectedDocPath; // Return path to load
            }
            return null;
        }

        function loadDocument(docUrl) {
            appState.currentDocumentUrl = docUrl;
            appState.activeElementId = null; // Deselect active element when changing doc
            updateSelectedElementControls();

            if (appState.backgroundImage && appState.backgroundImage.src.endsWith(docUrl)) {
                 // If same image, just ensure redraw, useful if only elements changed.
                 // However, loadDocument implies a full reload/resize might be needed.
                 // For simplicity, always reload image details.
            }
            appState.backgroundImage = new Image();
            appState.backgroundImage.onload = () => {
                const canvasContainer = mainCanvas.parentElement;
                const containerStyle = getComputedStyle(canvasContainer);
                const imageAspectRatio = appState.backgroundImage.naturalWidth / appState.backgroundImage.naturalHeight;
                let displayWidth, displayHeight;

                displayWidth = canvasContainer.clientWidth;
                displayHeight = displayWidth / imageAspectRatio;

                let containerMaxHeight = parseFloat(containerStyle.maxHeight);
                if (isNaN(containerMaxHeight) || containerMaxHeight <= 0) {
                    containerMaxHeight = window.innerHeight * 0.75; 
                }
                if (displayHeight > containerMaxHeight) {
                    displayHeight = containerMaxHeight;
                    displayWidth = displayHeight * imageAspectRatio;
                }
                displayWidth = Math.min(displayWidth, canvasContainer.clientWidth);
                if (Math.abs(displayWidth - canvasContainer.clientWidth) > 1 && (displayWidth / imageAspectRatio > displayHeight) ) { // Check if width constraint was primary
                     displayHeight = displayWidth / imageAspectRatio; // Recalculate if width was capped
                }


                mainCanvas.style.width = displayWidth + 'px';
                mainCanvas.style.height = displayHeight + 'px';
                mainCanvas.width = displayWidth * dpr;
                mainCanvas.height = displayHeight * dpr;
                
                // Configure main context (reset transform and scale)
                mainCtx = mainCanvas.getContext('2d'); // Re-get context if canvas object changed (it doesn't here, but good practice)
                configureDrawingContext(mainCtx, displayWidth, displayHeight); // Use logical dimensions
                mainCtx.imageSmoothingEnabled = true; // Enable for background image
                mainCtx.imageSmoothingQuality = "high";

                redrawMainCanvas();
            };
            appState.backgroundImage.onerror = () => {
                console.error("Error cargando imagen del documento:", docUrl);
                 const logicalWidth = mainCanvas.style.width ? parseFloat(mainCanvas.style.width) : 300;
                 const logicalHeight = mainCanvas.style.height ? parseFloat(mainCanvas.style.height) : 200;
                 mainCanvas.width = logicalWidth * dpr; mainCanvas.height = logicalHeight * dpr;
                 configureDrawingContext(mainCtx, logicalWidth, logicalHeight);
                 mainCtx.fillStyle = "red"; mainCtx.font = "16px Arial"; mainCtx.textAlign = "center";
                 const currentDocConfig = documentConfigurations.find(dc => dc.path === docUrl);
                 const docName = currentDocConfig ? currentDocConfig.displayName : docUrl.split('/').pop();
                 mainCtx.fillText("Error al cargar: " + docName, logicalWidth / 2, logicalHeight / 2);
            }
            appState.backgroundImage.src = docUrl;
            setActiveDocumentButton(docUrl); // Highlight the correct button
        }
        
        function getElementById(docUrl, elementId) {
            if (docUrl && appState.documentSettings[docUrl]) {
                return appState.documentSettings[docUrl].elements.find(el => el.id === elementId);
            } return null;
        }

        function redrawMainCanvas(isExporting = false) {
            if (!mainCtx || !mainCanvas.width || !mainCanvas.height) return; // Canvas not ready
            const logicalWidth = mainCanvas.width / dpr;
            const logicalHeight = mainCanvas.height / dpr;

            if (!appState.currentDocumentUrl || !appState.backgroundImage || !appState.backgroundImage.complete || appState.backgroundImage.naturalWidth === 0) {
                if (logicalWidth > 0 && logicalHeight > 0) {
                    configureDrawingContext(mainCtx, logicalWidth, logicalHeight); // Ensure context is scaled
                    mainCtx.fillStyle = "gray"; mainCtx.font = "16px Arial"; mainCtx.textAlign = "center";
                    mainCtx.fillText("Cargando documento...", logicalWidth / 2, logicalHeight / 2);
                } return;
            }
            
            // Ensure context is configured for drawing (already scaled)
            // configureDrawingContext(mainCtx, logicalWidth, logicalHeight); // This clears, only drawImage needs it.
            // The context is scaled by loadDocument. ClearRect should use logical.
            mainCtx.clearRect(0, 0, logicalWidth, logicalHeight); 
            mainCtx.drawImage(appState.backgroundImage, 0, 0, logicalWidth, logicalHeight);

            const currentDocSettings = appState.documentSettings[appState.currentDocumentUrl];
            if (!currentDocSettings) return;

            currentDocSettings.elements.forEach(element => {
                const imageToDraw = appState[element.id + 'ImageCache']; 
                if (imageToDraw) {
                    mainCtx.drawImage(imageToDraw, element.x, element.y, element.width, element.height);
                    if (appState.activeElementId === element.id && !isExporting) {
                        mainCtx.strokeStyle = 'var(--selection-border-color)'; 
                        mainCtx.lineWidth = 2 / dpr; // Logical width 2px, scaled by DPR this means 2 physical pixels. No, should be logical.
                        mainCtx.lineWidth = 2; // Specify in logical pixels for a scaled context
                        mainCtx.setLineDash([6, 3]); // Specify in logical pixels
                        mainCtx.strokeRect(element.x - 1, element.y - 1, element.width + 2, element.height + 2); 
                        mainCtx.setLineDash([]); 
                    }
                }
            });
        }

        function calculateDistance(p1, p2) { 
            return Math.sqrt(Math.pow(p2.clientX - p1.clientX, 2) + Math.pow(p2.clientY - p1.clientY, 2));
        }

        function getCanvasCoordinates(event) { 
            const rect = mainCanvas.getBoundingClientRect();
            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX; clientY = event.touches[0].clientY;
            } else if (event.clientX !== undefined) {
                clientX = event.clientX; clientY = event.clientY;
            } else { return null; }
            return { x: clientX - rect.left, y: clientY - rect.top };
        }
        
        function isPointInElement(pointX, pointY, element) { 
            return pointX >= element.x && pointX <= element.x + element.width && 
                   pointY >= element.y && pointY <= element.y + element.height;
        }

        function handleCanvasTouchStart(event) {
             if (event.cancelable) event.preventDefault(); // Prevent scroll/zoom for all canvas touches
            if (event.touches.length === 1) {
                const coords = getCanvasCoordinates(event); 
                if (!coords) return;
                const currentDocSettings = appState.documentSettings[appState.currentDocumentUrl];
                if (!currentDocSettings) return;
                let selected = null;
                for (let i = currentDocSettings.elements.length - 1; i >= 0; i--) {
                    const el = currentDocSettings.elements[i];
                    if (isPointInElement(coords.x, coords.y, el)) { selected = el; break; }
                }
                appState.activeElementId = selected ? selected.id : null;
                if (selected) {
                    appState.dragState = { isDragging: true, elementId: selected.id, offsetX: coords.x - selected.x, offsetY: coords.y - selected.y };
                    appState.pinchState.isPinching = false; 
                } else {
                    appState.dragState.isDragging = false;
                }
            } else if (event.touches.length === 2 && appState.activeElementId) {
                const element = getElementById(appState.currentDocumentUrl, appState.activeElementId);
                if (!element) return;
                appState.dragState.isDragging = false; 
                appState.pinchState.isPinching = true;
                appState.pinchState.elementId = appState.activeElementId;
                appState.pinchState.initialPinchDistance = calculateDistance(event.touches[0], event.touches[1]);
                appState.pinchState.initialElement = { 
                    width: element.width, height: element.height, 
                    centerX: element.x + element.width / 2, centerY: element.y + element.height / 2,
                };
            }
            updateSelectedElementControls(); redrawMainCanvas(); 
        }
        
        function handleCanvasMouseDown(event) { 
            const coords = getCanvasCoordinates(event);
            if (!coords) return;
            const { x, y } = coords;
            const currentDocSettings = appState.documentSettings[appState.currentDocumentUrl];
            if (!currentDocSettings) return;
            let selected = null;
            for (let i = currentDocSettings.elements.length - 1; i >= 0; i--) {
                const el = currentDocSettings.elements[i];
                if (isPointInElement(x, y, el)) { selected = el; break; }
            }
            appState.activeElementId = selected ? selected.id : null;
            if (selected) {
                appState.dragState = { isDragging: true, elementId: selected.id, offsetX: x - selected.x, offsetY: y - selected.y };
            } else { appState.dragState.isDragging = false; }
            updateSelectedElementControls(); redrawMainCanvas();
            if (event.cancelable) event.preventDefault();
        }

        function handleCanvasTouchMove(event) {
            if (event.cancelable) event.preventDefault(); // Prevent scroll/zoom
            if (appState.pinchState.isPinching && event.touches.length === 2 && appState.pinchState.elementId === appState.activeElementId) {
                const element = getElementById(appState.currentDocumentUrl, appState.activeElementId);
                if (!element) { appState.pinchState.isPinching = false; return; }
                const currentPinchDistance = calculateDistance(event.touches[0], event.touches[1]);
                if (appState.pinchState.initialPinchDistance < 1) return;  
                let scale = currentPinchDistance / appState.pinchState.initialPinchDistance;
                scale = Math.max(0.05, scale); 
                const newWidth = appState.pinchState.initialElement.width * scale;
                const newHeight = appState.pinchState.initialElement.height * scale;
                element.width = Math.max(20, newWidth); element.height = Math.max(20, newHeight);
                element.x = appState.pinchState.initialElement.centerX - element.width / 2;
                element.y = appState.pinchState.initialElement.centerY - element.height / 2;
                redrawMainCanvas();
                elementWidthInput.value = Math.round(element.width);
                elementHeightInput.value = Math.round(element.height);
            } else if (appState.dragState.isDragging && appState.dragState.elementId === appState.activeElementId && event.touches.length === 1) {
                 const coords = getCanvasCoordinates(event); 
                if (!coords) return;
                const element = getElementById(appState.currentDocumentUrl, appState.dragState.elementId);
                if (element) {
                    element.x = coords.x - appState.dragState.offsetX;
                    element.y = coords.y - appState.dragState.offsetY;
                    redrawMainCanvas();
                }} else if (appState.pinchState.isPinching && event.touches.length !== 2) {
                appState.pinchState.isPinching = false; 
            }
        }

        function handleCanvasMouseMove(event) { 
            if (!appState.dragState.isDragging || !appState.dragState.elementId) return;
            const coords = getCanvasCoordinates(event);
            if (!coords) return;
            const element = getElementById(appState.currentDocumentUrl, appState.dragState.elementId);
            if (element) {
                element.x = coords.x - appState.dragState.offsetX;
                element.y = coords.y - appState.dragState.offsetY;
                redrawMainCanvas();
            }
            if (event.cancelable) event.preventDefault();
        }

        function handleCanvasInteractionEnd(event) { 
            if (appState.pinchState.isPinching && (!event.touches || event.touches.length < 2)) {
                appState.pinchState.isPinching = false; appState.pinchState.elementId = null;
            }
            if (appState.dragState.isDragging && (!event.touches || event.touches.length === 0)) { 
                appState.dragState.isDragging = false;
            }
             // Update controls in case size changed via pinch and then finger lifted
            if(appState.activeElementId) updateSelectedElementControls();
        }
        
        function updateSelectedElementControls() {
            const activeElement = appState.activeElementId ? getElementById(appState.currentDocumentUrl, appState.activeElementId) : null;
            if (activeElement) { 
                elementSizingControls.style.display = 'block';
                imageElementControls.style.display = 'block'; 
                elementWidthInput.value = Math.round(activeElement.width);
                elementHeightInput.value = Math.round(activeElement.height);
            } else { elementSizingControls.style.display = 'none'; }
        }

        function handleSizeInputChange() { 
            const activeElement = appState.activeElementId ? getElementById(appState.currentDocumentUrl, appState.activeElementId) : null;
            if (!activeElement) return;
            activeElement.width = parseInt(elementWidthInput.value, 10) || 100; 
            activeElement.height = parseInt(elementHeightInput.value, 10) || 50;
            redrawMainCanvas();
        }
        
        let lastResizeTimestamp = 0;
        const resizeDebounceTime = 250; // ms

        function handleAppResize() {
            const now = Date.now();
            if (now - lastResizeTimestamp < resizeDebounceTime && !(window.innerWidth === appState.lastWindowWidth && window.innerHeight === appState.lastWindowHeight)) {
                // If rapid resize events, but actual dimensions changed, still allow some processing
                // This simple debounce might still lose intermediate states if not careful with how often pads are re-init.
                // For now, just re-init and reload.
            }
            lastResizeTimestamp = now;
            appState.lastWindowWidth = window.innerWidth;
            appState.lastWindowHeight = window.innerHeight;

            // Re-setup drawing pads: adjust their buffer size and re-scale context
            // This WILL clear unconfirmed drawings.
            // A more advanced solution would be to only do this if display dimensions actually changed.
            initializeDrawingPads(); // This also clears the pads
            
            if (appState.currentDocumentUrl && appState.backgroundImage && appState.backgroundImage.src) { // Check if src is set
                 // Re-trigger image load to correctly resize main canvas.
                 // Pass a flag or check if it's the same image to potentially optimize
                 // but for robustness, a full re-evaluation of dimensions is safer on resize.
                loadDocument(appState.currentDocumentUrl); 
            }
        }

        function setupEventListeners() {
            clearNameBtn.addEventListener('click', () => clearDrawingPad(nameCtx, 'nameImageCache'));
            confirmNameBtn.addEventListener('click', () => confirmDrawingPad(nameCtx, 'nameImageCache'));
            clearCedulaBtn.addEventListener('click', () => clearDrawingPad(cedulaCtx, 'cedulaImageCache'));
            confirmCedulaBtn.addEventListener('click', () => confirmDrawingPad(cedulaCtx, 'cedulaImageCache'));
            clearDateBtn.addEventListener('click', () => clearDrawingPad(dateCtx, 'dateImageCache')); 
            confirmDateBtn.addEventListener('click', () => confirmDrawingPad(dateCtx, 'dateImageCache'));
            clearSignatureBtn.addEventListener('click', () => clearDrawingPad(sigCtx, 'signatureImageCache'));
            confirmSignatureBtn.addEventListener('click', () => confirmDrawingPad(sigCtx, 'signatureImageCache'));

            mainCanvas.addEventListener('mousedown', handleCanvasMouseDown);
            mainCanvas.addEventListener('mousemove', handleCanvasMouseMove);
            mainCanvas.addEventListener('mouseup', handleCanvasInteractionEnd);
            mainCanvas.addEventListener('mouseleave', handleCanvasInteractionEnd); 
            mainCanvas.addEventListener('touchstart', handleCanvasTouchStart, { passive: false });
            mainCanvas.addEventListener('touchmove', handleCanvasTouchMove, { passive: false });
            mainCanvas.addEventListener('touchend', handleCanvasInteractionEnd, { passive: false }); 

            elementWidthInput.addEventListener('input', handleSizeInputChange); 
            elementHeightInput.addEventListener('input', handleSizeInputChange);
            exportDocumentBtn.addEventListener('click', () => {
                if (!appState.currentDocumentUrl || !appState.backgroundImage || !appState.backgroundImage.complete || appState.backgroundImage.naturalWidth === 0) {
                    alert("Por favor, seleccione y cargue un documento primero, o espere a que cargue."); return;
                }
                const lastActiveElement = appState.activeElementId;
                appState.activeElementId = null; 
                redrawMainCanvas(true); 
                const dataUrl = mainCanvas.toDataURL('image/jpeg', 0.92); 
                const link = document.createElement('a'); link.href = dataUrl;
                const currentDocConfig = documentConfigurations.find(dc => dc.path === appState.currentDocumentUrl);
                const shortNameForFile = currentDocConfig ? currentDocConfig.shortName : 'documento';
                const dateForFile = new Date().toISOString().slice(0,10).replace(/-/g,'');
                link.download = `APC_Firmado_${shortNameForFile}_${dateForFile}.jpg`;
                document.body.appendChild(link); link.click(); document.body.removeChild(link);
                appState.activeElementId = lastActiveElement; 
                if(lastActiveElement) redrawMainCanvas(); 
            });
            window.addEventListener('resize', handleAppResize);
        }

        // --- Initialization ---
        initializeDefaultDocumentSettings();
        populateDocumentButtons(); // Call for buttons
        initializeDrawingPads(); 
        
        let initialDocPathToLoad = handleUrlParameters();
        if (!initialDocPathToLoad && documentConfigurations.length > 0) {
            initialDocPathToLoad = documentConfigurations[0].path;
        }

        if (initialDocPathToLoad) {
            loadDocument(initialDocPathToLoad);
        } else {
            console.error("No hay documentos APC configurados o no se pudo determinar el documento inicial.");
            if(mainCanvas.width === 0 && mainCanvas.height === 0) { // Ensure canvas has some dimensions for error message
                mainCanvas.style.width = "300px"; mainCanvas.style.height = "150px";
                mainCanvas.width = 300 * dpr; mainCanvas.height = 150 * dpr;
            }
            mainCtx = mainCanvas.getContext('2d'); // ensure context is fresh if it wasn't
            configureDrawingContext(mainCtx, mainCanvas.width/dpr, mainCanvas.height/dpr);
            mainCtx.fillStyle = "red"; mainCtx.font = "16px Arial"; mainCtx.textAlign = "center";
            mainCtx.fillText("No hay documentos.", mainCanvas.width/(2*dpr), mainCanvas.height/(2*dpr));
        }
        setupEventListeners(); // Setup event listeners after everything is initialized
    </script>
</body>
</html>
